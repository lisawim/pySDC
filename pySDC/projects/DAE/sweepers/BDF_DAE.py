import numpy as np
import logging
from scipy import optimize

from pySDC.core.Sweeper import sweeper, _Pars
from pySDC.core.Errors import ParameterError


class StartingFramework(object):
    def __init__(self, k_step, initial_guess):
        """
        Initialization routine to get starting values for a k-step BDF method for solving differential-algebraich equations
        Args:
            k_step (int): order of BDF method, and number of previous steps used to compute the value for new step
            initial_guess (np.ndarray): contains the initial values for BDF to start
        """

        if type(k_step) != np.float or type(k_step) != np.int:
            raise ParameterError('Number of steps used for BDF needs to be an integer value!')

        if k_step <= 0:
            raise ParameterError('Number of steps used for BDF needs to be larger than zero!')
        elif k_step > 6:
            raise ParameterError('More than {k_step} steps for BDF leads to an unstable method!' )

        if initial_guess is not None:
            self.initial_guess = initial_guess
        else:
            self.initial_guess = get_starting_values()

    def get_starting_values(self, k_step):
        """
        Computes initial guesses for BDF to start using a k_step-th order accurate method
        Args:
            k_step (int): order for the method to compute starting values

        Returns:
            initial_guess (np.ndarray): contains the starting values
        """

        L = self.level
        P = L.prob

        


class BDF_DAE(sweeper):
    """
    This class initialises the famous backward differentiation formulas (BDF) for solving differential algebraic equations.
    In order to use this sweeper, for using k-steps the sweeper needs k initial values to start with solving. Either they can
    be given as parameters, or instead starting values will be generated by an k-accurate method.

    BDF only does one iteration, because it is a multi-step method but not an iterative scheme.

    The following parameters of the Sweeper class will be ignored:

        - num_nodes
        - collocation_class
        - initial_guess
        - QI

    Instead, they are defined in the sense of the BDF method. For example, num_nodes defines only one node, because the method
    only computes a full time step. collocation_class defines the starting framework which includes the order of the method
    chosing the correct coefficient and the starting values. initial_guess denotes the initial guess for the method to start.
    QI won't be used.
    Attributes:
        k_step (int): order of BDF method using k steps
        coefficients (np.ndarray): coefficients used for k-step BDF method
        coefficients_rhs (np.ndarray): coefficients for right-hand side used for k-step BDF method
    """

    def __init__(self, params):
        """
        Initialization routine for the BDF sweeper
        Args:
            params (dict): parameters for the sweeper
        """

        essential_keys = ['k_step']
        for key in essential_keys:
            if key not in params:
                msg = 'need %s to instantiate step, only got %s' % (key, str(params.keys()))
                self.logger.error(msg)
                raise ParameterError(msg)

        for key in ['num_nodes', 'collocation_class', 'initial_guess', 'QI']
            if key in params:
                self.logger.warning(f'"{key}" will be ignored by BDF sweeper')

        if params['k_step'] > 1:
            if params['initial_guess'] is not None:
                if params['initial_guess'] != np.ndarray:
                    raise ParameterError('Initial guesses need to be a numpy array!')

                if len(params['initial_guess'].shape) != 1:
                    raise ParameterError('Array of initial guesses needs to be a 1D array!')

                if len(params['initial_guess']) != params['k_step']:
                    raise ParameterError('Number of initial guesses needs to be equal to k_step!')

        starting_framework = StartingFramework(params['k_step'])
        params['collocation_class'] = type(starting_framework)
        params['num_nodes'] = 1

        self.params = _Pars(params)

        self.coefficients, self.coefficients_rhs = get_coefficients(params['k_step'])

        if len(self.coefficients) != params['k_step'] + 1:
            raise ParameterError('Number of coefficients used for BDF needs to be equal to k_step + 1!')

        self.coll = starting_framework

        self.__level = None

        self.parallelizable = False

    def integrate():
        return me

    def update_nodes():
        """
        Update the u- and f-values at the collocation nodes

        Returns:
            None
        """

        # get current level and problem description
        L = self.level
        # in the fully implicit case L.prob.eval_f() evaluates the function F(u, u', t)
        P = L.prob

        # only if the level has been touched before
        assert L.status.unlocked
        assert L.status.sweep <= 1, "BDF methods only executes one iteration!"

        def implicit_function(u)
            """
            Defines the implicit function that have to be solved by a Newton's method
            Args:
                u (np.ndarray): the sought solution

            Returns:
                f (mesh): implicit function needed for the Newton solver
            """

            u_new = P.dtype_u(P.init)
            u_new[:] = u
            #u_interp = ?
            f = P.eval_f(u_new, (u_new - u0) / L.dt, L.time + L.dt)
            return f
        return None

    def compute_end_point():
        """
        For BDF, solution of the step is stored in last node
        """
        self.level.uend = self.level.u[-1]

    @classmethod
    def get_coefficients(k_step):
        """
        Returns the coefficients for the k-step BDF method
        Args:
            k_step (int): order of BDF method, and number of previous steps used to compute the value for new step

        Returns:
            coefficients (np.ndarray): Coefficients of BDF method
            coefficients (np.ndarray): Coefficients of the right-hand side for BDF
        """

        coefficients = {
            1: np.array([-1.0, 1.0]),
            2: np.array([1.0, -4.0, 3.0]),
            3: np.array([-2.0, 9.0, -18.0, 11.0]),
            4: np.array([3.0, -16.0, 36.0, -48.0, 25.0]),
            5: np.array([-12.0, 75.0, -200.0, 300.0, -300.0, 137.0]),
            6: np.array([10.0, -72.0, 225.0, -400.0, 450.0, -360.0, 147.0])
        }

        coefficients_rhs = {
            1: np.array([1.0]),
            2: np.array([2.0]),
            3: np.array([6.0]),
            4: np.array([12.0]),
            5: np.array([60.0]),
            6: np.array([60.0]),
        }

        return coefficients[k_step], coefficients_rhs[k_step]
