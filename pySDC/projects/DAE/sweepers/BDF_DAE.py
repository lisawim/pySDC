import numpy as np
import logging
from scipy import optimize

from pySDC.core.Sweeper import sweeper, _Pars
from pySDC.core.Errors import ParameterError


class StartingFramework(object):
    def __init__(self, k_step, starting_values):
        """
        Initialization routine to get starting values for a k-step BDF method for solving differential-algebraic equations.
        If no starting_values are implemented in order to start BDF, there will be some computed using the
        initial condition u0 implemented in the problem class.

        Args:
            k_step (int): order of BDF method, and number of previous steps used to compute the value for new step
            starting_values (np.ndarray): contains the initial values for BDF to start
            num_nodes (int): number of nodes used for one step (which is only one)
        """

        if not isinstance(k_step, int):
            raise ParameterError('Number of steps used for BDF needs to be an integer value!')

        if k_step <= 0:
            raise ParameterError('Number of steps used for BDF needs to be larger than zero!')
        elif k_step > 6:
            raise ParameterError('More than {k_step} steps for BDF leads to an unstable method!' )

        if starting_values is not None:
            self.starting_values = starting_values
        else:
            if k_step > 1:
                raise ParameterError(f'Possibility of computing starting_values for {k_step}-step BDF to start not implemented yet!')

        self.num_nodes = 1
        self.tleft = 0.0
        self.tright = 1.0

    def get_starting_values(self, k_step):
        """
        Computes starting values for BDF to start using a k_step-th order accurate method

        Args:
            k_step (int): order for the method to compute starting values

        Returns:
            starting_values (np.ndarray): contains the starting values
        """
        raise NotImplementedError('There is not an method implemented to compute starting values for BDF!')


class BDF_DAE(sweeper):
    """
    This class initialises the famous backward differentiation formulas (BDF) for solving differential algebraic equations.
    In order to use this sweeper, for using k-steps the sweeper needs k values to start with solving. Either they can
    be given as parameters, or instead starting values will be generated by an k-accurate method.

    BDF only does one iteration, because it is a multi-step method but not an iterative scheme.

    The following parameters of the Sweeper class will be ignored:

        - num_nodes
        - collocation_class
        - initial_guess
        - QI

    Instead, they are defined in the sense of the BDF method. For example, num_nodes defines only one node, because the method
    only computes a full time step. collocation_class defines the starting framework which includes the order of the method
    chosing the correct coefficient and the starting values. initial_guess and QI won't be used.

    Attributes:
        k_step (int): order of BDF method using k steps
        coefficients (np.ndarray): coefficients used for k-step BDF method
        coefficients_rhs (np.ndarray): coefficients for right-hand side used for k-step BDF method
        u_last (np.ndarray): contains the last k_step values for BDF
    """

    def __init__(self, params):
        """
        Initialization routine for the BDF sweeper
        Args:
            params (dict): parameters for the sweeper
        """

        # set up logger
        self.logger = logging.getLogger('sweeper')

        essential_keys = ['k_step', 'starting_values']
        for key in essential_keys:
            if key not in params:
                if key == 'starting_values':
                    params['starting_values'] = None
                else:
                    msg = 'need %s to instantiate step, only got %s' % (key, str(params.keys()))
                    self.logger.error(msg)
                    raise ParameterError(msg)

        for key in ['quad_type', 'num_nodes', 'collocation_class', 'initial_guess', 'QI']:
            if key in params:
                self.logger.warning(f'"{key}" will be ignored by BDF sweeper')

        if params['k_step'] > 1:
            raise NotImplementedError('BDF method for k_step > 1 is not implemented yet!')

        if params['k_step'] > 1:
            if params['starting_values'] is not None:
                if params['starting_values'] != np.ndarray:
                    raise ParameterError('Starting values need to be a numpy array!')

                if len(params['starting_values'].shape) != 1:
                    raise ParameterError('Array of starting values needs to be a 1D array!')

                if len(params['starting_values']) != params['k_step']:
                    raise ParameterError(f'Number of starting values needs to be equal to {k_step}!')

        starting_framework = StartingFramework(params['k_step'], params['starting_values'])
        params['collocation_class'] = starting_framework
        params['num_nodes'] = starting_framework.num_nodes

        self.params = _Pars(params)

        self.coefficients, self.coefficients_rhs = self.get_coefficients(params['k_step'])
        self.u_last = None

        if len(self.coefficients) != params['k_step'] + 1:
            raise ParameterError(f'Number of coefficients used for BDF needs to be equal to {k_step} + 1!')

        self.coll = starting_framework

        self.__level = None

        self.parallelizable = False

    def predict(self):
        """
        Initialises the u and the f at the level
        """

        L = self.level
        P = L.prob

        # evaluate RHS at left point
        L.f[0] = P.dtype_f(init=P.init, val=0.0)

        for m in range(self.coll.num_nodes):
            L.u[m + 1] = P.dtype_u(init=P.init, val=0.0)
            L.f[m + 1] = P.dtype_f(init=P.init, val=0.0)

        # indicate that this level is now ready for sweeps
        L.status.unlocked = True
        L.status.updated = True
        return None

    def update_nodes(self):
        """
        Update the u- and f-values at the collocation nodes

        Returns:
            None
        """

        # get current level and problem description
        L = self.level
        # in the fully implicit case L.prob.eval_f() evaluates the function F(u, u', t)
        P = L.prob

        # only if the level has been touched before
        assert L.status.unlocked
        assert L.status.sweep <= 1, "BDF methods only execute one iteration!"

        def implicit_function(u):
            """
            Defines the implicit function that have to be solved by a Newton's method
            Args:
                u (np.ndarray): the sought solution

            Returns:
                f (mesh): implicit function needed for the Newton solver
            """

            u_new = P.dtype_u(P.init)
            u_new[:] = u
            u_interp = (u_new - L.u[0])  # has to be extended when k_step > 1 is possible
            f = P.eval_f(u_new, u_interp / L.dt, L.time + L.dt)
            return f

        # defines the option for the Newton solver
        options = {
            'xtol': P.newton_tol,
            'eps': 1e-7,
        }

        solve = optimize.root(
            implicit_function,
            L.u[0],
            method='hybr',
            options=options,
        )

        u_new = solve.x
        L.u[-1][:] = u_new
        L.f[-1][:] = (u_new - L.u[0]) / L.dt  # has to be extended when k_step > 1 is possible

        # indicate presence of new values at this level
        L.status.updated = True

        return None

    def compute_residual(self):
        """
        Overrides the base implementation
        Uses the absolute value of the implicit function ||F(u', u, t)|| as the residual
        Returns:
            None
        """

        L = self.level
        P = L.prob

        # compute the residual at the end of the interval
        res_norm = []
        for m in range(self.coll.num_nodes):
            res_norm.append(abs(P.eval_f(L.u[m + 1], L.f[m], L.time + m * L.dt)))

        # find maximal residual over the nodes
        if L.params.residual_type == 'full_abs':
            L.status.residual = max(res_norm)
        elif L.params.residual_type == 'last_abs':
            L.status.residual = res_norm[-1]
        elif L.params.residual_type == 'full_rel':
            L.status.residual = max(res_norm) / abs(L.u[0])
        elif L.params.residual_type == 'last_rel':
            L.status.residual = res_norm[-1] / abs(L.u[0])
        else:
            raise ParameterError(
                f'residual_type = {L.params.residual_type} not implemented, choose '
                f'full_abs, last_abs, full_rel or last_rel instead'
            )

        # indicate that the residual has seen the new values
        L.status.updated = False

        return None

    def compute_end_point(self):
        """
        For BDF, solution of the step is stored in last node
        """
        self.level.uend = self.level.u[-1]

    @classmethod
    def get_coefficients(self, k_step):
        """
        Returns the coefficients for the k-step BDF method
        Args:
            k_step (int): order of BDF method, and number of previous steps used to compute the value for new step

        Returns:
            coefficients (np.ndarray): Coefficients of BDF method
            coefficients (np.ndarray): Coefficients of the right-hand side for BDF
        """

        coefficients = {
            1: np.array([-1.0, 1.0]),
            2: np.array([1.0, -4.0, 3.0]),
            3: np.array([-2.0, 9.0, -18.0, 11.0]),
            4: np.array([3.0, -16.0, 36.0, -48.0, 25.0]),
            5: np.array([-12.0, 75.0, -200.0, 300.0, -300.0, 137.0]),
            6: np.array([10.0, -72.0, 225.0, -400.0, 450.0, -360.0, 147.0])
        }

        coefficients_rhs = {
            1: np.array([1.0]),
            2: np.array([2.0]),
            3: np.array([6.0]),
            4: np.array([12.0]),
            5: np.array([60.0]),
            6: np.array([60.0]),
        }

        return coefficients[k_step], coefficients_rhs[k_step]

    @classmethod
    def get_last_values(k_step):
        """
        Returns the last k_step values which are needed for BDF to compute the solution for the next time step.

        Args:
            k_step (int): order of BDF method, and number of previous steps used to compute the value for new step

        Returns:
            u_last (np.ndarray): solution of u for the last k_step time steps
        """
        raise NotImplementedError('Cannot get last values because BDF for k_step > 1 is not implemented yet!')
